# Калькулятор выражений с операциями min и max

Постановка задачи
Используя структуру стека, вычислить выражение, содержащее две операции: поиск минимума (обозначается m(,)) и поиск максимума (обозначается М(,)). Операции могут быть вложенными, например, M(15, m(16,8)) (в данном выражении ищем минимум из 16 и 8, а потом ищем максимум от результата m(16,8) и 15, ответ 15). В качестве аргументов могут использоваться только целые положительные числа. Строка, вводимая пользователем, корректна и не содержит пробелов.

Ключевые требования:
Поддержка вложенных выражений (например, M(5, m(3, 4)))
Обработка только целых положительных чисел
Полная проверка корректности входных данных
Интерактивный интерфейс с возможностью выхода

Основная структура: Стек (класс Stack)
Обоснование выбора стека:
1. Последняя открытая операция должна обрабатываться первой
Пример для M(5, m(3, 4)):
Операции: M → m
Аргументы: 5 → ( → 3 → 4

2. Эффективность операций:
Все операции со стеком (push/pop/peek) выполняются за O(1)
Общая сложность алгоритма - O(n), где n - длина выражения

3. Простота реализации:
Позволяет избежать рекурсии
Четкое разделение между числами и операциями

Альтернативы и почему они не подошли:
Рекурсивный спуск: Риск переполнения стека при глубокой вложенности
Дерево выражений: Избыточно для данной задачи
Очередь: Не соответствует логике обработки вложенных операций

Алгоритм решения
Основные этапы:
1. Инициализация:
Создание пустого стека
Загрузка словаря операций {'m': min, 'M': max}

2. Парсинг выражения:
for char in expression:
    if char is digit:
        # Собираем полное число
    elif char is operation:
        stack.push(char)
    elif char is '(':
        stack.push(char)
    elif char is ')':
        # Вычисляем операцию
3. Вычисление операции:
Извлекаем аргументы до '('
Проверяем что аргументов ровно 2
Применяем операцию
Результат кладем обратно в стек

4. Завершение:
В стеке должен остаться ровно 1 элемент (результат)
Иначе - ошибка формата


Классы и их ответственность:
1. Stack:
Инкапсуляция: self._items - защищенное поле
Публичный интерфейс: push(), pop(), peek()
Почему класс? - Для повторного использования и изоляции логики

2. ExpressionCalculator:
Инкапсуляция: self._operations - защищенное поле
Разделение ответственности:
calculate() - основной алгоритм
_apply_operation() - внутренняя логика


1. Инкапсуляция:
Все поля начинаются с _ - соглашение о защищенном доступе
Внутренние методы (_apply_operation) не предназначены для внешнего вызова

2. Наследование:
Не используется, так как нет иерархии объектов

3. Полиморфизм:
Проявляется в словаре операций:
{'m': min, 'M': max}  # Один интерфейс для разных операций


Особенности реализации
Парсинг чисел:
while i < n and expression[i].isdigit():
    num_str.append(expression[i])
    i += 1
stack.push(int(''.join(num_str)))
Почему так? - Для поддержки многоразрядных чисел (например, 123)

Обработка скобок:
elif char == ')':
    result = self._apply_operation(stack)
    stack.push(result)
Почему отдельный метод? - Для изоляции сложной логики вычислений

Игнорирование пробелов:
elif char == ',' or char == ' ':
    i += 1
Почему явная проверка? - По условию задачи можно было не обрабатывать, но сделано для удобства
